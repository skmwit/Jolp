"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.strictKeysRt = void 0;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("io-ts"));
const Either_1 = require("fp-ts/lib/Either");
const lodash_1 = require("lodash");
const merge_rt_1 = require("../merge_rt");
function getKeysInObject(object, prefix = '') {
    const keys = [];
    lodash_1.forEach(object, (value, key) => {
        const ownPrefix = prefix ? `${prefix}.${key}` : key;
        keys.push(ownPrefix);
        if (lodash_1.isPlainObject(object[key])) {
            keys.push(...getKeysInObject(object[key], ownPrefix));
        }
    });
    return keys;
}
function addToContextWhenValidated(type, prefix) {
    const validate = (input, context) => {
        const result = type.validate(input, context);
        const keysType = context[0].type;
        if (!('trackedKeys' in keysType)) {
            throw new Error('Expected a top-level StrictKeysType');
        }
        if (Either_1.isRight(result)) {
            keysType.trackedKeys.push(...Object.keys(type.props).map((propKey) => `${prefix}${propKey}`));
        }
        return result;
    };
    if (type._tag === 'InterfaceType') {
        return new t.InterfaceType(type.name, type.is, validate, type.encode, type.props);
    }
    return new t.PartialType(type.name, type.is, validate, type.encode, type.props);
}
function trackKeysOfValidatedTypes(type, prefix = '') {
    if (!('_tag' in type)) {
        return type;
    }
    const taggedType = type;
    switch (taggedType._tag) {
        case 'IntersectionType': {
            const collectionType = type;
            return t.intersection(collectionType.types.map((rt) => trackKeysOfValidatedTypes(rt, prefix)));
        }
        case 'UnionType': {
            const collectionType = type;
            return t.union(collectionType.types.map((rt) => trackKeysOfValidatedTypes(rt, prefix)));
        }
        case 'MergeType': {
            const collectionType = type;
            return merge_rt_1.mergeRt(...collectionType.types.map((rt) => trackKeysOfValidatedTypes(rt, prefix)));
        }
        case 'PartialType': {
            const propsType = type;
            return addToContextWhenValidated(t.partial(lodash_1.mapValues(propsType.props, (val, key) => trackKeysOfValidatedTypes(val, `${prefix}${key}.`))), prefix);
        }
        case 'InterfaceType': {
            const propsType = type;
            return addToContextWhenValidated(t.type(lodash_1.mapValues(propsType.props, (val, key) => trackKeysOfValidatedTypes(val, `${prefix}${key}.`))), prefix);
        }
        case 'ExactType': {
            const exactType = type;
            return t.exact(trackKeysOfValidatedTypes(exactType.type, prefix));
        }
        default:
            return type;
    }
}
class StrictKeysType extends t.Type {
    constructor(type) {
        const trackedType = trackKeysOfValidatedTypes(type);
        super('strict_keys', trackedType.is, (input, context) => {
            this.trackedKeys.length = 0;
            return Either_1.either.chain(trackedType.validate(input, context), (i) => {
                const originalKeys = getKeysInObject(input);
                const excessKeys = lodash_1.difference(originalKeys, this.trackedKeys);
                if (excessKeys.length) {
                    return t.failure(i, context, `Excess keys are not allowed: \n${excessKeys.join('\n')}`);
                }
                return t.success(i);
            });
        }, trackedType.encode);
        this.trackedKeys = [];
    }
}
function strictKeysRt(type) {
    return new StrictKeysType(type);
}
exports.strictKeysRt = strictKeysRt;
//# sourceMappingURL=index.js.map